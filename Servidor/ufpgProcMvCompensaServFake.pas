{*******************************************************}
{*
{* ufpgProcMvCompensaServFake.pas
{* Delphi Implementation of the Class TefpgProcMvCompensaServFake
{* Generated by Enterprise Architect
{* Created on:      03-jun-2013 15:41:44
{* Original author: maxback
{*
{*******************************************************}

unit ufpgProcMvCompensaServFake;

interface

uses
  SysUtils, spServidor_TLB, uspEntidade, uspConjuntoDados, uspGeraCodigo,
  uspAtualizacao, uspServidorAplicacao, usajConstante, ufpgProcMvCompensaServ,
  ufpgProcMvCompensa, DBClient, DB, uspClientDataSet, ActiveX, usaj4Geral,
  uspTestCase, Classes, uspFuncoesDataSet;

type

  //Classe que serve ao propósito de permitir o teste dos métodos da classe
  //TefpgProcMvCompensaServ sem a depedência do acesso ao banco de dados.

  //@remark 03/06/2013 - maxback - SALT 61989/1 -
  TefpgProcMvCompensaServFake = class(TefpgProcMvCompensaServ)
  private
    FnCdForoRegistrosRemovidos: integer;
    FnCdVaraRegistrosRemovidos: integer;
    FoTabelaVirtualProcMvCompensa: TspClientDataSet;
    FoTabelaVirtualProcesso: TspClientDataSet;
    FoPesoQtSaidoMovimentProcesso: TStringList;

    procedure AtualizarCamposCalculadosProcMvCompensa;
    procedure DefinirEstruturaTabelaVirtualProcMvCompensa;
    procedure DefinirEstruturaTabelaVirtualProcesso;
    procedure DefinirMetadadosSelectDadosUltDistrib(poConjuntoDados: TspConjuntoDados;
      psSpSelect: string);
    function GetfpgPesoQtSaidoMovimentProcesso(psProcesso: string): integer;
  protected
    /// <summary>
    ///  Inicia uma transação.
    /// </summary>
    /// <param name="psLocal">
    /// </param>
    /// <returns>
    ///  None
    /// </returns>
    /// <remarks>
    ///  //17/06/2013 - maxback - SALT 61989/1 - Quebra de dependência.
    /// </remarks>
    procedure IniciarTransacaoInterno(const psLocal: string); override;

    /// <summary>
    ///  Confirma uma transação.
    /// </summary>
    /// <returns>
    ///  None
    /// </returns>
    /// <remarks>
    ///  //17/06/2013 - maxback - SALT 61989/1 - Quebra de dependência.
    /// </remarks>
    procedure EfetuarCommitNaTransacaoInterno; override;

    /// <summary>
    ///  Confirma uma transação.
    /// </summary>
    /// <returns>
    ///  None
    /// </returns>
    /// <remarks>
    ///  //17/06/2013 - maxback - SALT 61989/1 - Quebra de dependência.
    /// </remarks>
    procedure EfetuarRollbackNaTransacaoInterno; override;

    /// <summary>
    ///  Salva os dados alterados/inseridos/removidos na entidade.
    /// </summary>
    /// <param name="poConjuntoDados">
    /// </param>
    /// <returns>
    ///  None
    /// </returns>
    /// <remarks>
    ///  //17/06/2013 - maxback - SALT 61989/1
    ///  Quebra de dependência do método salve do conjunto de dados.
    /// </remarks>
    procedure SalvarNoBancoDeDados(poConjuntoDados: TspConjuntoDados); override;

    /// <summary>
    /// Define os metadados para um conjunto de dados com o objetivo de preparar o mesmo para
    /// inserir dados.
    /// </summary>
    /// <param name="poConjuntoDados">
    /// </param>
    /// <param name="psSpSelect">
    /// </param>
    /// <returns>
    ///  None
    /// </returns>
    /// <remarks>
    ///  //17/06/2013 - maxback - SALT 61989/1
    /// Quebra de dependência do método metadados do conjunto de dados.
    /// </remarks>
    procedure DefinirMetadados(poConjuntoDados: TspConjuntoDados; psSpSelect: string); override;


    /// <summary>
    ///  Retorna o objeto spDB a ser usado em funções e criação de conjuntos de dados no servidor.
    /// </summary>
    /// <returns>
    ///  olevariant
    /// </returns>
    /// <remarks>
    /// //17/06/2013 - maxback - SALT 61989/1
    /// Quebra de dependência do objeto spDB.
    /// </remarks>
    function PegarSpDB: olevariant; override;

    /// <summary>
    ///  Consulta a quantidade de registros de compensação associados com as movimentação de
    ///  um processo.
    /// </summary>
    /// <param name="psCdProcesso"> Código do processo.
    /// </param>
    /// <returns>
    ///  integer - Quantidade de registros existentes. Retorna 0 se não encontrar nenhum registro
    ///  ou for passado um valor nulo em psCdProcesso.
    /// </returns>
    /// <remarks>
    /// //04/06/2013 - maxback - SALT 61989/1 -
    /// </remarks>
    function ConsultarQuantidadeDadosProcMvCompensaInterno(psCdProcesso: WideString): integer;
      override;

    /// <summary>
    ///  Método retorna o objeto de entidade do tipo TefpgProcMvCompensa com os dados dos registros
    ///  referentes a movimentação passada por parâmetro.
    /// </summary>
    /// <param name="poConjuntoDados"> Conjunto de dados para a pesquisa.
    /// </param>
    /// <param name="psCdProcesso"> Código do processo cuja movimentação compensa distribuição.
    /// </param>
    /// <param name="pnNuSeqProcessoMv"> Numero sequencial da movimentação compensa distribuição.
    /// NUMERO_INDEFINIDO).
    /// </param>
    /// <remarks>
    /// //04/06/2013 - maxback - SALT 61989/1 - psCdProcesso e pnNuSeqProcessoMv definem as chaves da
    /// pesquisa. Se omitido o numero do processo apenas os metadados são retornado (por segurança).
    ///
    /// Este Método foi criado desta forma principalmente para quebra de dependência necessária  ao
    /// teste unitário da classe.
    ///
    ///  Retorna no select os dados da ultima distribuição do processo necessários para avaliar a
    ///  necessidade de realizar o ajuste de pesos ao se excluir um registro.
    ///  //12/06/2013 - maxback - SALT 61989/1 - Adicionado poConjuntoDados: TspConjuntoDados;
    ///  //17/06/2013 - maxback - SALT 61989/1 - Alterado apra ficar apenas com a quebra de
    ///  dependência.
    /// </remarks>
    procedure ConsultarDadosProcMvCompensaInterno(poConjuntoDados: TspConjuntoDados;
      const psCdProcesso: WideString; const pnNuSeqProcessoMv: integer); override;

    /// <summary>
    /// Consulta os dados do processo referente a data de distribuição e inicio de
    /// contabilização de pesos;
    /// </summary>
    /// <param name="poConjuntoDados"> Conjunto de dados para a pesquisa.
    /// </param>
    /// <param name="psCdProcesso"> (String) </param>
    /// <returns> Retorna um conjunto de dados com as informações.
    /// </returns>
    /// <remarks>
    /// //05/06/2013 - maxback - SALT 61989/1 -
    /// Criado para poder quebra dependência da entidade de processo.
    ///  //12/06/2013 - maxback - SALT 61989/1 - Adicionado poConjuntoDados: TspConjuntoDados;
    /// </remarks>
    /// </remarks>
    procedure ConsultarDadosProcessoDadosDistribInterno(poConjuntoDados: TspConjuntoDados;
      const psCdProcesso: string); override;

    /// <summary>
    ///  Exclui todos os registros de compensação de pesos de movimentações associadas a processo
    ///  de determinada vara.
    /// </summary>
    /// <param name="pnCdForo"> Código do foro da chave primária da tabela de varas.
    /// </param>
    /// <param name="pnCdVara"> Código da vara da chave primária da tabela de varas.
    /// NUMERO_INDEFINIDO).
    /// </param>
    /// <remarks>
    /// //04/06/2013 - maxback - SALT 61989/1 - Criado para executar os comandos SQL apropriados
    /// para cada banco e permitir a quebra de dependência de banco nos testes.
    /// Realiza via comando SQL delete pois pode trata-se de grande quantidade de registros
    /// </remarks>
    procedure ExcluirRegistrosCompensaDistribuicaoPorVaraInterno(
      const pnCdForo, pnCdVara: integer); override;

    /// <summary>
    /// Criado pAra quEbrar a depedência da chamada a outra entidade para ajuste de pesos.
    /// </sumary>
    /// <remarks>
    /// //18/06/2013 - maxback - SALT 61989/1 - Renomeado de AlterarPesosProcMvCompensaInterno para
    /// AlterarPesosProcMvCompensaInterno a fim de possibildiat quebra de dependêcias.
    /// </remarks>
    procedure AlterarPesosProcMvCompensaInterno(poDados: TspConjuntoDados;
      const pbIncrementarPesoMv: boolean); override;


  public
    constructor spCreate(AOwner: TspServidorAplicacao; const guid: TGUID;
      const DispIntf: TGUID); override;
    destructor Destroy; override;
    property fpgCdForoRegistrosRemovidos: integer 
      read FnCdForoRegistrosRemovidos   write FnCdForoRegistrosRemovidos;
    property fpgCdVaraRegistrosRemovidos: integer 
      read FnCdVaraRegistrosRemovidos   write FnCdVaraRegistrosRemovidos;
    property fpgPesoQtSaidoMovimentProcesso[psProcesso: string]: integer   
      read GetfpgPesoQtSaidoMovimentProcesso;
    property fpgTabelaVirtualProcMvCompensa: TspClientDataSet read FoTabelaVirtualProcMvCompensa;
    property fpgTabelaVirtualProcesso: TspClientDataSet read FoTabelaVirtualProcesso;

  end;

implementation


{implementation of TefpgProcMvCompensaServFake}

constructor TefpgProcMvCompensaServFake.spCreate(AOwner: TspServidorAplicacao;
  const guid, DispIntf: TGUID);
begin
  inherited spCreate(AOwner, guid, DispIntf);
  FoTabelaVirtualProcMvCompensa := TspClientDataSet.Create(nil); //PC_OK
  FoTabelaVirtualProcesso := TspClientDataSet.Create(nil); //PC_OK
  FoPesoQtSaidoMovimentProcesso := TStringList.Create; //PC_OK
  FnCdForoRegistrosRemovidos := NUMERO_INDEFINIDO;
  FnCdVaraRegistrosRemovidos := NUMERO_INDEFINIDO;
  DefinirEstruturaTabelaVirtualProcMvCompensa;
  DefinirEstruturaTabelaVirtualProcesso;
end;


destructor TefpgProcMvCompensaServFake.Destroy;
begin
  FreeAndNil(FoPesoQtSaidoMovimentProcesso); //PC_OK
  FreeAndNil(FoTabelaVirtualProcesso); //PC_OK
  FreeAndNil(FoTabelaVirtualProcMvCompensa); //PC_OK
  inherited;
end;


procedure TefpgProcMvCompensaServFake.DefinirMetadados(poConjuntoDados: TspConjuntoDados;
  psSpSelect: string);
begin
  //inherited;
  DefinirMetadadosSelectDadosUltDistrib(poConjuntoDados, psSpSelect);
end;

procedure TefpgProcMvCompensaServFake.DefinirMetadadosSelectDadosUltDistrib(
  poConjuntoDados: TspConjuntoDados; psSpSelect: string);
begin
  if UpperCase(psSpSelect) <> 'SELECTDADOSULTDISTRIB' then
    Exit;

  poConjuntoDados.Filtered := False;
  poConjuntoDados.Data := FoTabelaVirtualProcMvCompensa.Data;
  while not poConjuntoDados.EOF do
    poConjuntoDados.Delete;

  poConjuntoDados.MergeChangeLog;
  poConjuntoDados.CancelUpdates;
end;

procedure TefpgProcMvCompensaServFake.EfetuarCommitNaTransacaoInterno;
begin
  //inherited;

end;

procedure TefpgProcMvCompensaServFake.EfetuarRollbackNaTransacaoInterno;
begin
  //inherited;

end;

procedure TefpgProcMvCompensaServFake.IniciarTransacaoInterno(const psLocal: string);
begin
  //inherited;

end;

function TefpgProcMvCompensaServFake.PegarSpDB: olevariant;
begin
  result := null;
end;

procedure TefpgProcMvCompensaServFake.SalvarNoBancoDeDados(poConjuntoDados: TspConjuntoDados);
begin
  //inherited;
  TspTestCase.SalvarAlteracoesNaTabelaVirtual(FoTabelaVirtualProcMvCompensa,
    poConjuntoDados, FoTabelaVirtualProcMvCompensa.IndexFieldNames);

  AtualizarCamposCalculadosProcMvCompensa;
end;

procedure TefpgProcMvCompensaServFake.DefinirEstruturaTabelaVirtualProcMvCompensa;
begin
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('CDPROCESSO', ftString, 13, True);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('NUSEQPROCESSOMV', ftFloat, 0, True);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('CDUSUINCLUSAO', ftFloat, 0, False);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('DTUSUINCLUSAO', ftDateTime, 0, False);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('CC_DTDISTRIBUICAO', ftDateTime, 0, False);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('CC_CDFORO', ftFloat, 0, False);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('CC_CDVARA', ftFloat, 0, False);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('CC_CDCARTORIO', ftFloat, 0, False);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('CC_CDFOROVAGA', ftFloat, 0, False);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('CC_CDVARAVAGA', ftFloat, 0, False);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('CC_CDVAGA', ftFloat, 0, False);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('CC_CDGRUPOPESO', ftFloat, 0, False);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('CC_NUFAIXADIST', ftFloat, 0, False);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('CC_FLREUPRESO', ftString, 1, False);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('CC_DTINICIOPESOVARA', ftDateTime, 0, False);
  FoTabelaVirtualProcMvCompensa.FieldDefs.Add('CC_TPDISTRIBUICAO', ftString, 1, False);
  FoTabelaVirtualProcMvCompensa.CreateDataSet;
  FoTabelaVirtualProcMvCompensa.Active := True;

  FoTabelaVirtualProcMvCompensa.IndexFieldNames := 'CDPROCESSO;NUSEQPROCESSOMV';
end;

function TefpgProcMvCompensaServFake.ConsultarQuantidadeDadosProcMvCompensaInterno(
  psCdProcesso: WideString): integer;
begin
  result := 0;
  if psCdProcesso = STRING_INDEFINIDO then
    Exit;

  FoTabelaVirtualProcMvCompensa.filter := 'cdProcesso = ' + QuotedStr(psCdProcesso);
  FoTabelaVirtualProcMvCompensa.filtered := True;
  try
    result := FoTabelaVirtualProcMvCompensa.RecordCount;
  finally
    FoTabelaVirtualProcMvCompensa.filtered := False;
  end;
end;

procedure TefpgProcMvCompensaServFake.ConsultarDadosProcMvCompensaInterno(
  poConjuntoDados: TspConjuntoDados; const psCdProcesso: WideString;
  const pnNuSeqProcessoMv: integer);
begin
  TspTestCase.CriarDadosConsulta(poConjuntoDados, FoTabelaVirtualProcMvCompensa,
    Format('cdProcesso = ''%s'' and nuSeqProcessoMv = %d', [psCdProcesso, pnNuSeqProcessoMv]));
end;

procedure TefpgProcMvCompensaServFake.ConsultarDadosProcessoDadosDistribInterno(
  poConjuntoDados: TspConjuntoDados; const psCdProcesso: string);
begin
  TspTestCase.CriarDadosConsulta(poConjuntoDados, FoTabelaVirtualProcesso,
    Format('cdProcesso = ''%s''', [psCdProcesso]));
end;

procedure TefpgProcMvCompensaServFake.ExcluirRegistrosCompensaDistribuicaoPorVaraInterno(
  const pnCdForo, pnCdVara: integer);
begin
  FnCdForoRegistrosRemovidos := pnCdForo;
  FnCdVaraRegistrosRemovidos := pnCdVara;
end;

procedure TefpgProcMvCompensaServFake.DefinirEstruturaTabelaVirtualProcesso;
begin
  FoTabelaVirtualProcesso.FieldDefs.Add('CDPROCESSO', ftString, 13, False);
  FoTabelaVirtualProcesso.FieldDefs.Add('CC_DTDISTRIBUICAO', ftDateTime, 0, False);
  FoTabelaVirtualProcesso.FieldDefs.Add('CC_CDFORO', ftFloat, 0, False);
  FoTabelaVirtualProcesso.FieldDefs.Add('CC_CDVARA', ftFloat, 0, False);
  FoTabelaVirtualProcesso.FieldDefs.Add('CC_CDCARTORIO', ftFloat, 0, False);
  FoTabelaVirtualProcesso.FieldDefs.Add('CC_CDFOROVAGA', ftFloat, 0, False);
  FoTabelaVirtualProcesso.FieldDefs.Add('CC_CDVARAVAGA', ftFloat, 0, False);
  FoTabelaVirtualProcesso.FieldDefs.Add('CC_CDVAGA', ftFloat, 0, False);
  FoTabelaVirtualProcesso.FieldDefs.Add('CC_CDGRUPOPESO', ftFloat, 0, False);
  FoTabelaVirtualProcesso.FieldDefs.Add('CC_NUFAIXADIST', ftFloat, 0, False);
  FoTabelaVirtualProcesso.FieldDefs.Add('CC_FLREUPRESO', ftString, 1, False);
  FoTabelaVirtualProcesso.FieldDefs.Add('CC_DTINICIOPESOVARA', ftDateTime, 0, False);
  FoTabelaVirtualProcesso.FieldDefs.Add('CC_TPDISTRIBUICAO', ftString, 1, False);
  FoTabelaVirtualProcesso.CreateDataSet;
  FoTabelaVirtualProcesso.Active := True;
  FoTabelaVirtualProcesso.IndexFieldNames := 'CDPROCESSO';
end;

//18/06/2013 - maxback - SALT 61989/1 -
procedure TefpgProcMvCompensaServFake.AlterarPesosProcMvCompensaInterno(poDados: TspConjuntoDados;
  const pbIncrementarPesoMv: boolean);
var
  sCdProcesso: string;
  nValor: integer;
begin
  sCdProcesso := poDados.FieldByName('CDPROCESSO').AsString;
  nValor := StrToIntDef(FoPesoQtSaidoMovimentProcesso.Values[sCdProcesso], 0);

  nValor := nValor + iIIF(pbIncrementarPesoMv, +1, -1);

  FoPesoQtSaidoMovimentProcesso.Values[sCdProcesso] := IntToStr(nValor);
end;

procedure TefpgProcMvCompensaServFake.AtualizarCamposCalculadosProcMvCompensa;
var
  sCdProcesso: string;
begin
  FoTabelaVirtualProcMvCompensa.First;
  while not FoTabelaVirtualProcMvCompensa.EOF do
  begin
    sCdProcesso := FoTabelaVirtualProcMvCompensa.FieldByName('CDPROCESSO').AsString;
    if FoTabelaVirtualProcesso.Locate('CDPROCESSO', sCdProcesso, []) then
    begin
      CopiaCamposCoincidentes(FoTabelaVirtualProcesso, FoTabelaVirtualProcMvCompensa,
        STRING_INDEFINIDO, True);
    end;
    FoTabelaVirtualProcMvCompensa.Next;
  end;
end;

function TefpgProcMvCompensaServFake.GetfpgPesoQtSaidoMovimentProcesso(
  psProcesso: string): integer;
var
  sValor: string;
begin
  sValor := FoPesoQtSaidoMovimentProcesso.Values[psProcesso];
  result := StrToIntDef(sValor, NUMERO_INDEFINIDO);
end;

end.

